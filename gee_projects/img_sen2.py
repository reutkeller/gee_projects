# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/satellite_data/sentinel_2.ipynb.

# %% auto 0
__all__ = ['access_s2_image', 'BAI', 'NDVI']

# %% ../nbs/satellite_data/sentinel_2.ipynb 3
import geopandas as gpd
import seaborn as sns
from shapely.geometry import Point
import json
import ee
import geemap
from datetime import datetime

ee.Authenticate()
ee.Initialize(project='ee-reutkeller')

from . import util_func as utils
from . import const_vars as const
from . import mask_s2 as mask_s2

# %% ../nbs/satellite_data/sentinel_2.ipynb 5
class access_s2_image():
  
  def __init__(self,
               path_to_geometry : str , # path to geometry file, can be .shp or .gpkg . example : r"D:\git\gee_maps\nbs\geometry\test_bbox.gpkg"
               crs : str , #coordinate reference system to work with
               start_date : str , # Start date for searching images. , 
               end_date : str , # End date for searching images.

               one_day_image : str == True , # when True, image will be generated for the neares date to the provided user_date, else, median image between the two dates will be generated. 
               user_date : str==None , # The user-provided date of interest; the script accesses the image with the closest available date to the provided date
               ):
    
    # if one_day_image and user_date is None:
    #   raise ValueError("Error:if one_day_image is True, user_date cannot be None. Please insert a date or change one_day_image to False to get aggregated image.")
        
    if one_day_image is False:
      print('calculating median image between dates {start_date} / {end_date}')
    self.crs = crs
    self.fc = utils.gdf_to_featureCollection(
      utils.read_gdf(geometry_path=path_to_geometry,crs=self.crs))
    self.start_date=start_date
    self.end_date=end_date
    self.one_day_image = one_day_image
    self.user_date = user_date
    
    self.fc = utils.gdf_to_featureCollection(utils.read_gdf
                                        (geometry_path=path_to_geometry,crs=self.crs))
    
    #pre process s2
    s2_sr_cld_col_eval = mask_s2.get_s2_sr_cld_col(self.fc, self.start_date, self.end_date)

    self.s2_sr = (s2_sr_cld_col_eval.map(mask_s2.add_cld_shdw_mask)
             .map(mask_s2.apply_cld_shdw_mask))

    if one_day_image:

      #get list of available dates of the image collection
      self.available_dates = utils.list_dates(self.s2_sr)
      self.closest_date = utils.find_closest_date(date_list = self.available_dates,
                                                  user_date=self.user_date)
      
      #filter image collection to get the image from the closest date :
      print(f'Requested date: {self.user_date}\n' 
            f'The nearest date available: {self.closest_date}')
      
      day_before_day_after = utils.get_day_before_day_after(self.closest_date)
      self.img = self.s2_sr.filterDate(day_before_day_after[0], day_before_day_after[1]).mosaic().clip(self.fc).divide(10000)
    
    else:
      self.img = self.s2_sr.median().clip(self.fc).divide(10000)


# %% ../nbs/satellite_data/sentinel_2.ipynb 9
def BAI(img):
    bai_img=img.expression(
        '(1-((B6*B7*B8A)/B4)**0.5)*((B12-B8A)/((B12+B8A)**0.5)+1)', {
                'B6': img.select('B6'),
                'B7': img.select('B7'),
                'B8A': img.select('B8A'),
                'B4': img.select('B4'),
                'B12': img.select('B12')})

    return bai_img

# %% ../nbs/satellite_data/sentinel_2.ipynb 10
def NDVI(img):
    NDVI_img=img.expression(
        '(B8-B4)/(B8+B4)', {
                'B8': img.select('B8'),
                'B4': img.select('B4')})

    return NDVI_img
